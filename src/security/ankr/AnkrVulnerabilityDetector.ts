/**
 * Ankr Vulnerability Detector
 * 
 * Detects potential vulnerabilities in Ankr Network smart contracts based on:
 * - Known audit findings (Halborn Aug 2024, Veridise Apr 2024, Beosin, Salus)
 * - Transaction pattern analysis
 * - Real-time anomaly detection
 */

import { AnkrContractRegistry, AnkrContract, AnkrChain } from './AnkrContractRegistry.js';

// TODO: Integrate with TheWarden's Logger for consistency
// For now, using simple console-based logger to avoid circular dependencies
const logger = {
  info: (module: string, message: string) => console.log(`[${module}] ${message}`),
  warn: (module: string, message: string) => console.warn(`[${module}] ${message}`),
  error: (module: string, message: string) => console.error(`[${module}] ${message}`),
};
const MODULE = 'AnkrVulnerabilityDetector';

// Detection Thresholds - Configurable constants
const THRESHOLDS = {
  // Gas usage thresholds
  HIGH_GAS_DOS: 500000,
  VERY_HIGH_GAS: 1000000,
  LOW_GAS_COMPLEX_OP: 30000,
  FLASH_LOAN_GAS: 800000,
  
  // Value thresholds (in Wei)
  HIGH_VALUE_REENTRANCY: BigInt(10) * BigInt(10 ** 18), // 10 ETH
  FLASH_LOAN_VALUE: BigInt(50) * BigInt(10 ** 18), // 50 ETH
  LARGE_MINT: BigInt(1000) * BigInt(10 ** 18), // 1000 tokens
  
  // Batch analysis thresholds
  MIN_COORDINATED_TXS: 3,
  COORDINATED_TIMESPAN_MS: 60000, // 1 minute
} as const;

export enum VulnerabilitySeverity {
  CRITICAL = 'critical', // $500k potential
  HIGH = 'high',         // $50k potential
  MEDIUM = 'medium',     // $5k potential
  LOW = 'low',           // $1k potential
  INFORMATIONAL = 'informational',
}

export interface VulnerabilityFinding {
  severity: VulnerabilitySeverity;
  type: string;
  contract: AnkrContract;
  description: string;
  detectionMethod: string;
  evidenceHash?: string;
  potentialReward: string;
  recommendations: string[];
  relatedAudit?: string;
  timestamp: Date;
}

export interface TransactionPattern {
  txHash: string;
  from: string;
  to: string;
  value: string;
  functionSignature: string;
  gasUsed: string;
  blockNumber: number;
  timestamp: number;
}

/**
 * Detects vulnerabilities in Ankr contracts
 */
export class AnkrVulnerabilityDetector {
  private findings: VulnerabilityFinding[] = [];
  private monitoredContracts: Map<string, AnkrContract> = new Map();

  constructor() {
    this.initializeMonitoring();
  }

  private initializeMonitoring(): void {
    const contracts = AnkrContractRegistry.getHighPriorityContracts();
    logger.info(MODULE, `Initializing monitoring for ${contracts.length} high-priority contracts`);

    contracts.forEach((contract) => {
      this.monitoredContracts.set(contract.address.toLowerCase(), contract);
    });
  }

  /**
   * Analyze transaction for potential vulnerabilities
   * Enhanced with pattern correlation and anomaly detection
   */
  async analyzeTransaction(tx: TransactionPattern): Promise<VulnerabilityFinding[]> {
    const newFindings: VulnerabilityFinding[] = [];
    const contract = this.monitoredContracts.get(tx.to.toLowerCase());

    if (!contract) {
      return newFindings;
    }

    // Run all detectors
    newFindings.push(...this.detectDoSPatterns(tx, contract));
    newFindings.push(...this.detectValidationErrors(tx, contract));
    newFindings.push(...this.detectPrivilegeEscalation(tx, contract));
    newFindings.push(...this.detectReentrancyPatterns(tx, contract));
    newFindings.push(...this.detectOracleManipulation(tx, contract));
    newFindings.push(...this.detectFlashLoanExploits(tx, contract));
    newFindings.push(...this.detectUnauthorizedMinting(tx, contract));
    newFindings.push(...this.detectSuspiciousGasPatterns(tx, contract));

    this.findings.push(...newFindings);
    return newFindings;
  }

  private detectDoSPatterns(tx: TransactionPattern, contract: AnkrContract): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];

    if (
      contract.name === 'ankrBNB' &&
      (tx.functionSignature.toLowerCase().includes('flashunstake') ||
        tx.functionSignature.toLowerCase().includes('swap'))
    ) {
      const gasUsed = parseInt(tx.gasUsed);
      if (gasUsed > THRESHOLDS.HIGH_GAS_DOS) {
        findings.push({
          severity: VulnerabilitySeverity.HIGH,
          type: 'Flash Unstake Fee DoS',
          contract,
          description: `Potential DoS attack on ${contract.name}. TX ${tx.txHash} used ${gasUsed} gas.`,
          detectionMethod: 'Gas usage anomaly + Known vulnerability pattern',
          evidenceHash: tx.txHash,
          potentialReward: 'Up to $50,000',
          recommendations: ['Verify swap function blockage', 'Create PoC demonstrating DoS'],
          relatedAudit: 'Veridise Apr 2024',
          timestamp: new Date(),
        });
      }
    }

    return findings;
  }

  private detectValidationErrors(tx: TransactionPattern, contract: AnkrContract): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];

    if (
      tx.from === '0x0000000000000000000000000000000000000000' ||
      tx.to === '0x0000000000000000000000000000000000000000'
    ) {
      findings.push({
        severity: VulnerabilitySeverity.MEDIUM,
        type: 'Missing Address Validation',
        contract,
        description: `TX ${tx.txHash} involves zero address.`,
        detectionMethod: 'Zero address detection',
        evidenceHash: tx.txHash,
        potentialReward: 'Up to $5,000',
        recommendations: ['Check address validation', 'Test with zero address'],
        relatedAudit: 'Beosin 2022-2023',
        timestamp: new Date(),
      });
    }

    return findings;
  }

  private detectPrivilegeEscalation(tx: TransactionPattern, contract: AnkrContract): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    const adminFunctions = ['setFee', 'setOracle', 'pause', 'unpause', 'transferOwnership'];
    const isAdminFunction = adminFunctions.some((fn) =>
      tx.functionSignature.toLowerCase().includes(fn.toLowerCase())
    );

    if (isAdminFunction) {
      findings.push({
        severity: VulnerabilitySeverity.CRITICAL,
        type: 'Privilege Escalation Attempt',
        contract,
        description: `Admin function ${tx.functionSignature} called by ${tx.from}.`,
        detectionMethod: 'Admin function call detection',
        evidenceHash: tx.txHash,
        potentialReward: 'Up to $500,000',
        recommendations: ['Verify authorization', 'Check access control modifiers'],
        relatedAudit: 'Salus May 2023',
        timestamp: new Date(),
      });
    }

    return findings;
  }

  private detectReentrancyPatterns(tx: TransactionPattern, contract: AnkrContract): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];

    if (
      tx.functionSignature.toLowerCase().includes('withdraw') ||
      tx.functionSignature.toLowerCase().includes('unstake')
    ) {
      const value = BigInt(tx.value);
      if (value > THRESHOLDS.HIGH_VALUE_REENTRANCY) {
        findings.push({
          severity: VulnerabilitySeverity.HIGH,
          type: 'Potential Re-entrancy',
          contract,
          description: `High-value withdrawal: ${tx.value}.`,
          detectionMethod: 'High-value withdrawal pattern',
          evidenceHash: tx.txHash,
          potentialReward: 'Up to $50,000',
          recommendations: ['Check re-entrancy guards', 'Test recursive calls'],
          timestamp: new Date(),
        });
      }
    }

    return findings;
  }

  private detectOracleManipulation(tx: TransactionPattern, contract: AnkrContract): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];

    if (
      tx.functionSignature.toLowerCase().includes('oracle') ||
      tx.functionSignature.toLowerCase().includes('price') ||
      tx.functionSignature.toLowerCase().includes('rate')
    ) {
      findings.push({
        severity: VulnerabilitySeverity.HIGH,
        type: 'Oracle Manipulation Risk',
        contract,
        description: `Oracle function called: ${tx.functionSignature}.`,
        detectionMethod: 'Oracle function detection',
        evidenceHash: tx.txHash,
        potentialReward: 'Up to $50,000',
        recommendations: ['Check oracle validation', 'Test with manipulated price'],
        relatedAudit: 'Halborn Aug 2024',
        timestamp: new Date(),
      });
    }

    return findings;
  }

  getFindings(): VulnerabilityFinding[] {
    return this.findings;
  }

  /**
   * Alias for getFindings() - provided for consistency with report generation APIs
   */
  getAllFindings(): VulnerabilityFinding[] {
    return this.getFindings();
  }

  getFindingsBySeverity(severity: VulnerabilitySeverity): VulnerabilityFinding[] {
    return this.findings.filter((f) => f.severity === severity);
  }

  getCriticalFindings(): VulnerabilityFinding[] {
    return this.getFindingsBySeverity(VulnerabilitySeverity.CRITICAL);
  }

  exportForSubmission(): string {
    return JSON.stringify(
      {
        summary: {
          total: this.findings.length,
          critical: this.getCriticalFindings().length,
          high: this.getFindingsBySeverity(VulnerabilitySeverity.HIGH).length,
        },
        findings: this.findings,
        generatedAt: new Date().toISOString(),
      },
      null,
      2
    );
  }

  clearFindings(): void {
    this.findings = [];
  }

  /**
   * Detect flash loan exploits
   * Monitors for suspicious patterns involving flash loans and liquid staking
   */
  private detectFlashLoanExploits(tx: TransactionPattern, contract: AnkrContract): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];

    // Check for flash loan related functions
    const flashLoanKeywords = ['flashloan', 'flash', 'borrow', 'flashunstake'];
    const hasFlashFunction = flashLoanKeywords.some(keyword =>
      tx.functionSignature.toLowerCase().includes(keyword)
    );

    if (hasFlashFunction) {
      const value = BigInt(tx.value);
      const gasUsed = parseInt(tx.gasUsed);

      // High value + flash operation = potential exploit
      if (value > THRESHOLDS.FLASH_LOAN_VALUE || gasUsed > THRESHOLDS.FLASH_LOAN_GAS) {
        findings.push({
          severity: VulnerabilitySeverity.CRITICAL,
          type: 'Flash Loan Exploit Attempt',
          contract,
          description: `Suspicious flash loan operation on ${contract.name}. Value: ${value.toString()}, Gas: ${gasUsed}`,
          detectionMethod: 'Flash loan pattern analysis + High value/gas detection',
          evidenceHash: tx.txHash,
          potentialReward: 'Up to $500,000',
          recommendations: [
            'Investigate transaction for manipulation of price oracles',
            'Check if staking/unstaking ratios were manipulated',
            'Verify if rewards were extracted improperly',
            'Review flash loan protection mechanisms'
          ],
          relatedAudit: 'Veridise Apr 2024 - Flash Unstake Vulnerabilities',
          timestamp: new Date(),
        });
      }
    }

    return findings;
  }

  /**
   * Detect unauthorized minting
   * Monitors for suspicious token minting patterns
   */
  private detectUnauthorizedMinting(tx: TransactionPattern, contract: AnkrContract): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];

    // Check for minting functions
    if (
      tx.functionSignature.toLowerCase().includes('mint') ||
      tx.functionSignature.toLowerCase().includes('stake')
    ) {
      const value = BigInt(tx.value);
      
      // Detect abnormally large mints (potential unauthorized minting)
      if (value > THRESHOLDS.LARGE_MINT) {
        findings.push({
          severity: VulnerabilitySeverity.CRITICAL,
          type: 'Suspicious Large Minting Operation',
          contract,
          description: `Abnormally large mint/stake: ${value.toString()} wei on ${contract.name}`,
          detectionMethod: 'Statistical anomaly detection on minting amounts',
          evidenceHash: tx.txHash,
          potentialReward: 'Up to $500,000',
          recommendations: [
            'Verify transaction authorization',
            'Check if minting ratio is correct',
            'Investigate source of deposited funds',
            'Review access control on mint function'
          ],
          relatedAudit: 'Salus May 2023 - Access Control Issues',
          timestamp: new Date(),
        });
      }

      // Detect minting with zero value (potential exploit)
      if (value === BigInt(0) && tx.functionSignature.toLowerCase().includes('mint')) {
        findings.push({
          severity: VulnerabilitySeverity.HIGH,
          type: 'Zero-Value Minting Attempt',
          contract,
          description: `Mint function called with zero value on ${contract.name}`,
          detectionMethod: 'Zero-value minting detection',
          evidenceHash: tx.txHash,
          potentialReward: 'Up to $50,000',
          recommendations: [
            'Check if tokens were minted without corresponding deposits',
            'Verify input validation on mint function',
            'Review business logic for edge cases'
          ],
          timestamp: new Date(),
        });
      }
    }

    return findings;
  }

  /**
   * Detect suspicious gas usage patterns
   * Advanced gas analysis for exploit detection
   */
  private detectSuspiciousGasPatterns(tx: TransactionPattern, contract: AnkrContract): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    const gasUsed = parseInt(tx.gasUsed);

    // Extremely high gas usage (potential loop exploit or DoS)
    if (gasUsed > THRESHOLDS.VERY_HIGH_GAS) {
      findings.push({
        severity: VulnerabilitySeverity.MEDIUM,
        type: 'Abnormal Gas Consumption',
        contract,
        description: `Transaction used ${gasUsed} gas, significantly above normal`,
        detectionMethod: 'Gas usage statistical analysis',
        evidenceHash: tx.txHash,
        potentialReward: 'Up to $5,000',
        recommendations: [
          'Investigate for unbounded loops',
          'Check for gas griefing attacks',
          'Review function complexity',
          'Consider gas optimization'
        ],
        relatedAudit: 'Beosin 2022-2023 - Gas Optimization',
        timestamp: new Date(),
      });
    }

    // Suspiciously low gas for complex operations
    if (gasUsed < THRESHOLDS.LOW_GAS_COMPLEX_OP && (
      tx.functionSignature.toLowerCase().includes('withdraw') ||
      tx.functionSignature.toLowerCase().includes('transfer') ||
      tx.functionSignature.toLowerCase().includes('stake')
    )) {
      findings.push({
        severity: VulnerabilitySeverity.LOW,
        type: 'Unusually Low Gas for Complex Operation',
        contract,
        description: `Complex operation used only ${gasUsed} gas - possible failed transaction or optimization bypass`,
        detectionMethod: 'Minimum gas threshold analysis',
        evidenceHash: tx.txHash,
        potentialReward: 'Up to $1,000',
        recommendations: [
          'Verify transaction actually succeeded',
          'Check for missing state updates',
          'Investigate potential gas estimation issues'
        ],
        timestamp: new Date(),
      });
    }

    return findings;
  }

  /**
   * Batch analysis for pattern correlation
   * Analyzes multiple transactions to find attack patterns
   */
  analyzeBatchTransactions(transactions: TransactionPattern[]): VulnerabilityFinding[] {
    const batchFindings: VulnerabilityFinding[] = [];
    
    // Group transactions by sender
    const txBySender = new Map<string, TransactionPattern[]>();
    transactions.forEach(tx => {
      const existing = txBySender.get(tx.from) || [];
      existing.push(tx);
      txBySender.set(tx.from, existing);
    });

    // Detect coordinated attack patterns
    txBySender.forEach((senderTxs, sender) => {
      if (senderTxs.length >= THRESHOLDS.MIN_COORDINATED_TXS) {
        // Multiple rapid transactions from same sender
        const timeSpan = Math.max(...senderTxs.map(tx => tx.timestamp)) - 
                        Math.min(...senderTxs.map(tx => tx.timestamp));
        
        if (timeSpan < THRESHOLDS.COORDINATED_TIMESPAN_MS) { // Less than configured timespan
          const contracts = [...new Set(senderTxs.map(tx => tx.to))];
          if (contracts.length > 1) {
            batchFindings.push({
              severity: VulnerabilitySeverity.HIGH,
              type: 'Coordinated Multi-Contract Attack Pattern',
              contract: this.monitoredContracts.get(contracts[0].toLowerCase())!,
              description: `Sender ${sender} executed ${senderTxs.length} transactions across ${contracts.length} contracts in ${timeSpan}ms`,
              detectionMethod: 'Multi-transaction pattern correlation analysis',
              evidenceHash: senderTxs[0].txHash,
              potentialReward: 'Up to $50,000',
              recommendations: [
                'Investigate for cross-contract reentrancy',
                'Check for atomic arbitrage or manipulation',
                'Review transaction sequence for logical exploits',
                'Consider implementing rate limiting'
              ],
              timestamp: new Date(),
            });
          }
        }
      }
    });

    return batchFindings;
  }

  /**
   * Get vulnerability statistics
   */
  getStatistics(): {
    total: number;
    bySeverity: Record<VulnerabilitySeverity, number>;
    byContract: Map<string, number>;
    byType: Map<string, number>;
  } {
    const stats = {
      total: this.findings.length,
      bySeverity: {
        [VulnerabilitySeverity.CRITICAL]: 0,
        [VulnerabilitySeverity.HIGH]: 0,
        [VulnerabilitySeverity.MEDIUM]: 0,
        [VulnerabilitySeverity.LOW]: 0,
        [VulnerabilitySeverity.INFORMATIONAL]: 0,
      },
      byContract: new Map<string, number>(),
      byType: new Map<string, number>(),
    };

    this.findings.forEach(finding => {
      stats.bySeverity[finding.severity]++;
      
      const contractCount = stats.byContract.get(finding.contract.name) || 0;
      stats.byContract.set(finding.contract.name, contractCount + 1);
      
      const typeCount = stats.byType.get(finding.type) || 0;
      stats.byType.set(finding.type, typeCount + 1);
    });

    return stats;
  }
}
