/**
 * Etherscan API TypeScript SDK
 * 
 * Auto-generated by TheWarden Autonomous Explorer
 * Complete implementation covering all 9 modules
 * 
 * @see https://docs.etherscan.io/introduction
 */

export interface EtherscanConfig {
  apiKey: string;
  chain?: 'ethereum' | 'base' | 'arbitrum' | 'optimism' | 'polygon' | 'bsc';
  baseUrl?: string;
  timeout?: number;
}

export interface EtherscanResponse<T = any> {
  status: string;
  message: string;
  result: T;
}

/**
 * Complete Etherscan API Client
 * Covers all 9 modules with full type safety
 */
export class EtherscanClient {
  private config: Required<EtherscanConfig>;
  
  constructor(config: EtherscanConfig) {
    this.config = {
      chain: 'ethereum',
      baseUrl: 'https://api.etherscan.io/v2/api',
      timeout: 30000,
      ...config
    };
  }

  // ========================================
  // ACCOUNT MODULE
  // ========================================
  
  public account = {
    /**
     * Get ETH balance for a single address
     */
    getBalance: async (address: string, tag: string = 'latest'): Promise<string> => {
      return this.request('account', 'balance', { address, tag });
    },
    
    /**
     * Get ETH balance for multiple addresses (max 20)
     */
    getBalanceMulti: async (addresses: string[], tag: string = 'latest'): Promise<Array<{ account: string; balance: string }>> => {
      return this.request('account', 'balancemulti', { 
        address: addresses.join(','), 
        tag 
      });
    },
    
    /**
     * Get list of normal transactions
     */
    getTransactions: async (address: string, options?: {
      startblock?: number;
      endblock?: number;
      page?: number;
      offset?: number;
      sort?: 'asc' | 'desc';
    }): Promise<any[]> => {
      return this.request('account', 'txlist', { address, ...options });
    },
    
    /**
     * Get list of internal transactions
     */
    getInternalTransactions: async (params: { 
      address?: string; 
      txhash?: string;
      startblock?: number;
      endblock?: number;
    }): Promise<any[]> => {
      return this.request('account', 'txlistinternal', params);
    },
    
    /**
     * Get ERC-20 token transfer events
     */
    getTokenTransfers: async (params: {
      address?: string;
      contractaddress?: string;
      startblock?: number;
      endblock?: number;
      page?: number;
      offset?: number;
      sort?: 'asc' | 'desc';
    }): Promise<any[]> => {
      return this.request('account', 'tokentx', params);
    },
    
    /**
     * Get ERC-721 NFT transfer events
     */
    getNFTTransfers: async (params: {
      address?: string;
      contractaddress?: string;
      startblock?: number;
      endblock?: number;
      page?: number;
      offset?: number;
      sort?: 'asc' | 'desc';
    }): Promise<any[]> => {
      return this.request('account', 'tokennfttx', params);
    },
    
    /**
     * Get list of blocks mined by address
     */
    getMinedBlocks: async (address: string, blocktype: 'blocks' | 'uncles' = 'blocks'): Promise<any[]> => {
      return this.request('account', 'getminedblocks', { address, blocktype });
    }
  };

  // ========================================
  // CONTRACT MODULE
  // ========================================
  
  public contract = {
    /**
     * Get contract ABI for verified contracts
     */
    getABI: async (address: string): Promise<string> => {
      return this.request('contract', 'getabi', { address });
    },
    
    /**
     * Get contract source code
     */
    getSourceCode: async (address: string): Promise<any[]> => {
      return this.request('contract', 'getsourcecode', { address });
    },
    
    /**
     * Get contract creation transaction
     */
    getCreation: async (addresses: string[]): Promise<any[]> => {
      return this.request('contract', 'getcontractcreation', {
        contractaddresses: addresses.slice(0, 5).join(',') // Max 5
      });
    }
  };

  // ========================================
  // TRANSACTION MODULE
  // ========================================
  
  public transaction = {
    /**
     * Check transaction execution status (0=fail, 1=pass)
     */
    getStatus: async (txhash: string): Promise<{ isError: string; errDescription: string }> => {
      return this.request('transaction', 'getstatus', { txhash });
    },
    
    /**
     * Get transaction receipt status
     */
    getReceiptStatus: async (txhash: string): Promise<{ status: string }> => {
      return this.request('transaction', 'gettxreceiptstatus', { txhash });
    }
  };

  // ========================================
  // BLOCK MODULE
  // ========================================
  
  public block = {
    /**
     * Get block and uncle rewards
     */
    getReward: async (blockno: number): Promise<any> => {
      return this.request('block', 'getblockreward', { blockno });
    },
    
    /**
     * Get estimated time to specific block
     */
    getCountdown: async (blockno: number): Promise<any> => {
      return this.request('block', 'getblockcountdown', { blockno });
    },
    
    /**
     * Get block number by timestamp
     */
    getByTimestamp: async (timestamp: number, closest: 'before' | 'after'): Promise<string> => {
      return this.request('block', 'getblocknobytime', { timestamp, closest });
    }
  };

  // ========================================
  // LOGS MODULE
  // ========================================
  
  public logs = {
    /**
     * Get event logs filtered by address and topics
     */
    getLogs: async (options: {
      address?: string;
      fromBlock?: number | 'latest';
      toBlock?: number | 'latest';
      topic0?: string;
      topic1?: string;
      topic2?: string;
      topic3?: string;
      topic0_1_opr?: 'and' | 'or';
      topic0_2_opr?: 'and' | 'or';
      topic0_3_opr?: 'and' | 'or';
      topic1_2_opr?: 'and' | 'or';
      topic1_3_opr?: 'and' | 'or';
      topic2_3_opr?: 'and' | 'or';
    }): Promise<any[]> => {
      return this.request('logs', 'getLogs', options);
    }
  };

  // ========================================
  // PROXY MODULE (JSON-RPC)
  // ========================================
  
  public proxy = {
    /**
     * Get latest block number
     */
    eth_blockNumber: async (): Promise<string> => {
      return this.request('proxy', 'eth_blockNumber', {});
    },
    
    /**
     * Get block by number
     */
    eth_getBlockByNumber: async (tag: string, fullTx: boolean): Promise<any> => {
      return this.request('proxy', 'eth_getBlockByNumber', { tag, boolean: fullTx });
    },
    
    /**
     * Get transaction by hash
     */
    eth_getTransactionByHash: async (txhash: string): Promise<any> => {
      return this.request('proxy', 'eth_getTransactionByHash', { txhash });
    },
    
    /**
     * Get transaction receipt
     */
    eth_getTransactionReceipt: async (txhash: string): Promise<any> => {
      return this.request('proxy', 'eth_getTransactionReceipt', { txhash });
    },
    
    /**
     * Execute contract call without creating transaction
     */
    eth_call: async (to: string, data: string, tag: string = 'latest'): Promise<string> => {
      return this.request('proxy', 'eth_call', { to, data, tag });
    },
    
    /**
     * Get contract bytecode
     */
    eth_getCode: async (address: string, tag: string = 'latest'): Promise<string> => {
      return this.request('proxy', 'eth_getCode', { address, tag });
    },
    
    /**
     * Get storage at position
     */
    eth_getStorageAt: async (address: string, position: string, tag: string = 'latest'): Promise<string> => {
      return this.request('proxy', 'eth_getStorageAt', { address, position, tag });
    },
    
    /**
     * Get current gas price
     */
    eth_gasPrice: async (): Promise<string> => {
      return this.request('proxy', 'eth_gasPrice', {});
    },
    
    /**
     * Estimate gas for transaction
     */
    eth_estimateGas: async (params: {
      to: string;
      value?: string;
      gasPrice?: string;
      gas?: string;
      data?: string;
    }): Promise<string> => {
      return this.request('proxy', 'eth_estimateGas', params);
    },
    
    /**
     * Get transaction count (nonce)
     */
    eth_getTransactionCount: async (address: string, tag: string = 'latest'): Promise<string> => {
      return this.request('proxy', 'eth_getTransactionCount', { address, tag });
    },
    
    /**
     * Send raw transaction
     */
    eth_sendRawTransaction: async (hex: string): Promise<string> => {
      return this.request('proxy', 'eth_sendRawTransaction', { hex });
    }
  };

  // ========================================
  // TOKEN MODULE
  // ========================================
  
  public token = {
    /**
     * Get top token holders
     */
    getHolders: async (contractaddress: string, page: number = 1, offset: number = 100): Promise<any[]> => {
      return this.request('token', 'tokenholderlist', { contractaddress, page, offset });
    },
    
    /**
     * Get token information
     */
    getInfo: async (contractaddress: string): Promise<any> => {
      return this.request('token', 'tokeninfo', { contractaddress });
    }
  };

  // ========================================
  // GAS TRACKER MODULE
  // ========================================
  
  public gas = {
    /**
     * Get current gas oracle (safe, propose, fast)
     */
    getOracle: async (): Promise<{
      LastBlock: string;
      SafeGasPrice: string;
      ProposeGasPrice: string;
      FastGasPrice: string;
      suggestBaseFee: string;
      gasUsedRatio: string;
    }> => {
      return this.request('gastracker', 'gasoracle', {});
    },
    
    /**
     * Estimate confirmation time for gas price
     */
    estimateConfirmation: async (gasprice: number): Promise<any> => {
      return this.request('gastracker', 'gasestimate', { gasprice });
    }
  };

  // ========================================
  // STATS MODULE
  // ========================================
  
  public stats = {
    /**
     * Get total ETH supply
     */
    getEthSupply: async (): Promise<string> => {
      return this.request('stats', 'ethsupply', {});
    },
    
    /**
     * Get ETH price (USD and BTC)
     */
    getEthPrice: async (): Promise<{
      ethbtc: string;
      ethbtc_timestamp: string;
      ethusd: string;
      ethusd_timestamp: string;
    }> => {
      return this.request('stats', 'ethprice', {});
    },
    
    /**
     * Get blockchain database size
     */
    getChainSize: async (params: {
      startdate: string; // YYYY-MM-DD
      enddate: string;   // YYYY-MM-DD
      clienttype: 'geth' | 'parity';
      syncmode: 'default' | 'archive';
      sort?: 'asc' | 'desc';
    }): Promise<any[]> => {
      return this.request('stats', 'chainsize', params);
    }
  };

  // ========================================
  // PRIVATE METHODS
  // ========================================
  
  private async request<T = any>(
    module: string,
    action: string,
    params: Record<string, any>
  ): Promise<T> {
    const chainId = this.getChainId();
    const queryParams = new URLSearchParams({
      chainid: chainId,
      module,
      action,
      apikey: this.config.apiKey,
      ...this.filterParams(params)
    });

    const url = `${this.config.baseUrl}?${queryParams.toString()}`;
    
    try {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), this.config.timeout);

      const response = await fetch(url, {
        signal: controller.signal
      });
      
      clearTimeout(timeout);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json() as EtherscanResponse<T>;
      
      if (data.status === '0') {
        throw new Error(`Etherscan API Error: ${data.message || data.result}`);
      }
      
      return data.result;
    } catch (error: any) {
      if (error.name === 'AbortError') {
        throw new Error(`Request timeout after ${this.config.timeout}ms`);
      }
      throw new Error(`Etherscan API request failed: ${error.message}`);
    }
  }

  private filterParams(params: Record<string, any>): Record<string, string> {
    const filtered: Record<string, string> = {};
    for (const [key, value] of Object.entries(params)) {
      if (value !== undefined && value !== null) {
        filtered[key] = String(value);
      }
    }
    return filtered;
  }

  private getChainId(): string {
    const chainIds: Record<string, string> = {
      ethereum: '1',
      base: '8453',
      arbitrum: '42161',
      optimism: '10',
      polygon: '137',
      bsc: '56'
    };
    return chainIds[this.config.chain!] || '1';
  }
}

/**
 * Convenience function to create client
 */
export function createEtherscanClient(config: EtherscanConfig): EtherscanClient {
  return new EtherscanClient(config);
}

/**
 * Export types for consumers
 */
export type { EtherscanConfig as EtherscanClientConfig, EtherscanResponse as EtherscanAPIResponse };
